# Stubs for wsproto.frame_protocol (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from .compat import Utf8Validator, unicode
from collections import namedtuple
from enum import IntEnum
from typing import Any, Optional

class XorMaskerSimple:
    def __init__(self, masking_key: Any) -> None: ...
    def process(self, data: Any): ...

class XorMaskerNull:
    def process(self, data: Any): ...

PAYLOAD_LENGTH_TWO_BYTE: int
PAYLOAD_LENGTH_EIGHT_BYTE: int
MAX_PAYLOAD_NORMAL: int
MAX_PAYLOAD_TWO_BYTE: Any
MAX_PAYLOAD_EIGHT_BYTE: Any
MAX_FRAME_PAYLOAD = MAX_PAYLOAD_EIGHT_BYTE
MASK_MASK: int
PAYLOAD_LEN_MASK: int
FIN_MASK: int
RSV1_MASK: int
RSV2_MASK: int
RSV3_MASK: int
OPCODE_MASK: int

class Opcode(IntEnum):
    CONTINUATION: int = ...
    TEXT: int = ...
    BINARY: int = ...
    CLOSE: int = ...
    PING: int = ...
    PONG: int = ...
    def iscontrol(self): ...

class CloseReason(IntEnum):
    NORMAL_CLOSURE: int = ...
    GOING_AWAY: int = ...
    PROTOCOL_ERROR: int = ...
    UNSUPPORTED_DATA: int = ...
    NO_STATUS_RCVD: int = ...
    ABNORMAL_CLOSURE: int = ...
    INVALID_FRAME_PAYLOAD_DATA: int = ...
    POLICY_VIOLATION: int = ...
    MESSAGE_TOO_BIG: int = ...
    MANDATORY_EXT: int = ...
    INTERNAL_ERROR: int = ...
    SERVICE_RESTART: int = ...
    TRY_AGAIN_LATER: int = ...
    TLS_HANDSHAKE_FAILED: int = ...

LOCAL_ONLY_CLOSE_REASONS: Any
MIN_CLOSE_REASON: int
MIN_PROTOCOL_CLOSE_REASON: int
MAX_PROTOCOL_CLOSE_REASON: int
MIN_LIBRARY_CLOSE_REASON: int
MAX_LIBRARY_CLOSE_REASON: int
MIN_PRIVATE_CLOSE_REASON: int
MAX_PRIVATE_CLOSE_REASON: int
MAX_CLOSE_REASON: int
NULL_MASK: Any

class ParseFailed(Exception):
    code: Any = ...
    def __init__(self, msg: Any, code: Any = ...) -> None: ...

Header = namedtuple('Header', ['fin', 'rsv', 'opcode', 'payload_len', 'masking_key'])

Frame = namedtuple('Frame', ['opcode', 'payload', 'frame_finished', 'message_finished'])

RsvBits = namedtuple('RsvBits', ['rsv1', 'rsv2', 'rsv3'])

class Buffer:
    buffer: Any = ...
    bytes_used: int = ...
    def __init__(self, initial_bytes: Optional[Any] = ...) -> None: ...
    def feed(self, new_bytes: Any) -> None: ...
    def consume_at_most(self, nbytes: Any): ...
    def consume_exactly(self, nbytes: Any): ...
    def commit(self) -> None: ...
    def rollback(self) -> None: ...
    def __len__(self): ...

class MessageDecoder:
    opcode: Any = ...
    validator: Any = ...
    decoder: Any = ...
    def __init__(self) -> None: ...
    def process_frame(self, frame: Any): ...
    def decode_payload(self, data: Any, finished: Any): ...

class FrameDecoder:
    client: Any = ...
    extensions: Any = ...
    buffer: Any = ...
    header: Any = ...
    effective_opcode: Any = ...
    masker: Any = ...
    payload_required: int = ...
    payload_consumed: int = ...
    def __init__(self, client: Any, extensions: Optional[Any] = ...) -> None: ...
    def receive_bytes(self, data: Any) -> None: ...
    def process_buffer(self): ...
    def parse_header(self): ...
    def parse_extended_payload_length(self, opcode: Any, payload_len: Any): ...
    def extension_processing(self, opcode: Any, rsv: Any, payload_len: Any) -> None: ...

class FrameProtocol:
    client: Any = ...
    extensions: Any = ...
    def __init__(self, client: Any, extensions: Any) -> None: ...
    def receive_bytes(self, data: Any) -> None: ...
    def received_frames(self) -> None: ...
    def close(self, code: Optional[Any] = ..., reason: Optional[Any] = ...): ...
    def ping(self, payload: bytes = ...): ...
    def pong(self, payload: bytes = ...): ...
    def send_data(self, payload: bytes = ..., fin: bool = ...): ...
